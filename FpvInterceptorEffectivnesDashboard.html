<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Аналіз ефективності Перехоплювачів</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #111827; color: #e5e7eb; }
        .chart-container { position: relative; height: 40vh; width: 100%; }
        .card { background-color: #1f2937; border: 1px solid #374151; border-radius: 0.75rem; padding: 1.5rem; box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1); }
        .kpi-value { font-size: 2.25rem; font-weight: 800; line-height: 1; }
        .kpi-label { font-size: 0.875rem; color: #9ca3af; text-transform: uppercase; }
        .loader-container { display: flex; flex-direction: column; justify-content: center; align-items: center; height: 80vh; }
        .loader { border: 4px solid #374151; border-top: 4px solid #3b82f6; border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .hidden { display: none; }
        /* Стилі для воронки */
        .html-funnel-container { display: flex; flex-direction: column; align-items: center; gap: 2px; width: 100%; height: 100%; min-height: 300px; justify-content: center; }
        .funnel-segment { height: 25%; color: white; text-align: center; display: flex; justify-content: center; align-items: center; position: relative; transition: transform 0.2s ease-in-out; padding: 0.5rem; box-sizing: border-box; }
        .funnel-segment-content { display: flex; flex-direction: column; gap: 2px; }
        .funnel-label { font-size: 0.875rem; font-weight: 600; }
        .funnel-value { font-size: 1.5rem; font-weight: 800; }
        .funnel-percentage { font-size: 0.75rem; color: #d1d5db; }
        /* Clip-path для створення ефекту воронки */
        #funnel-launches { background-color: rgba(59, 130, 246, 0.7); /* blue */ width: 100%; clip-path: polygon(0% 0, 100% 0, 92.5% 100%, 7.5% 100%); }
        #funnel-detection { background-color: rgba(251, 191, 36, 0.7); /* yellow */ width: 85%; clip-path: polygon(0% 0, 100% 0, 91.175% 100%, 8.825% 100%); }
        #funnel-attempt { background-color: rgba(249, 115, 22, 0.7); /* orange */ width: 70%; clip-path: polygon(0% 0, 100% 0, 89.285% 100%, 10.715% 100%); }
        #funnel-destroyed { background-color: rgba(34, 197, 94, 0.7); /* green */ width: 55%; clip-path: polygon(0% 0, 100% 0, 86.36% 100%, 13.64% 100%); }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
</head>
<body class="p-4 md:p-8">
    <div class="container mx-auto max-w-7xl">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-white">Аналіз ефективності Перехоплювачів</h1>
        </header>

        <!-- Loader -->
        <div id="loader" class="loader-container">
            <div class="loader"></div>
            <p id="loadingMessage" class="text-gray-400 mt-4">Завантаження даних з Google Sheets...</p>
        </div>

        <!-- Dashboard Content -->
        <div id="dashboardContent" class="hidden">
             <!-- Filters Section -->
            <div class="card mb-8">
                 <h2 class="text-xl font-semibold mb-4 text-white">Фільтри</h2>
                 <!-- Оновлена сітка: 8 елементів (6 інпутів, 2 дати), ідеально для 4 колонок -->
                 <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-4 items-end">
                    <div><label for="dateStart" class="block text-sm font-medium text-gray-300 mb-1">Дата початку</label><input type="date" id="dateStart" class="w-full bg-gray-700 border border-gray-600 rounded-lg p-2 text-white"></div>
                    <div><label for="dateEnd" class="block text-sm font-medium text-gray-300 mb-1">Дата кінця</label><input type="date" id="dateEnd" class="w-full bg-gray-700 border border-gray-600 rounded-lg p-2 text-white"></div>
                    <div><label for="sectorFilter" class="block text-sm font-medium text-gray-300 mb-1">Сектор</label><select id="sectorFilter" class="w-full bg-gray-700 border border-gray-600 rounded-lg p-2 text-white"></select></div>
                    <div><label for="crewFilter" class="block text-sm font-medium text-gray-300 mb-1">Екіпаж</label><select id="crewFilter" class="w-full bg-gray-700 border border-gray-600 rounded-lg p-2 text-white"></select></div>
                    
                    <div><label for="takeoffPointFilter" class="block text-sm font-medium text-gray-300 mb-1">Точка злету</label><select id="takeoffPointFilter" class="w-full bg-gray-700 border border-gray-600 rounded-lg p-2 text-white"></select></div>
                    <div><label for="targetTypeFilter" class="block text-sm font-medium text-gray-300 mb-1">Тип цілі</label><select id="targetTypeFilter" class="w-full bg-gray-700 border border-gray-600 rounded-lg p-2 text-white"></select></div>
                    <!-- Новий фільтр -->
                    <div><label for="droneTypeFilter" class="block text-sm font-medium text-gray-300 mb-1">Тип засобу</label><select id="droneTypeFilter" class="w-full bg-gray-700 border border-gray-600 rounded-lg p-2 text-white"></select></div>
                    
                    <!-- Кнопка тепер займає 1 колонку -->
                    <div><button id="clearFiltersButton" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-300">Очистити</button></div>
                 </div>
            </div>

            <!-- KPIs -->
            <h3 class="text-lg font-semibold mb-4 text-gray-300">Абсолютні Показники</h3>
            <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-4 mb-8">
                <div class="card text-center"><div id="kpiLaunches" class="kpi-value text-blue-400">0</div><div class="kpi-label">Кількість пусків</div></div>
                <div class="card text-center"><div id="kpiDetection" class="kpi-value text-yellow-400">0</div><div class="kpi-label">Візуальний контакт</div></div>
                <div class="card text-center"><div id="kpiAttempt" class="kpi-value text-orange-400">0</div><div class="kpi-label">Спроба ураження</div></div>
                <div class="card text-center"><div id="kpiDestroyed" class="kpi-value text-green-400">0</div><div class="kpi-label">Знищено</div></div>
                <div class="card text-center"><div id="kpiNotDestroyed" class="kpi-value text-red-400">0</div><div class="kpi-label">Промах (Втрачений)</div></div>
                <div class="card text-center"><div id="kpiReturned" class="kpi-value text-indigo-400">0</div><div class="kpi-label">Повернулось</div></div>
            </div>

            <h3 class="text-lg font-semibold mb-4 text-gray-300">Ключові Коефіцієнти Ефективності (ККЕ)</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-8">
                <div class="card text-center"><div id="kpiEffDetection" class="kpi-value text-yellow-300">0%</div><div class="kpi-label">Ефективність виявлення</div></div>
                <div class="card text-center"><div id="kpiEffAttempt" class="kpi-value text-orange-300">0%</div><div class="kpi-label">Ефективність спроб уражень</div></div>
                <div class="card text-center"><div id="kpiEffDestroy" class="kpi-value text-green-300">0%</div><div class="kpi-label">Ефективність знищення</div></div>
                <div class="card text-center"><div id="kpiEffMiss" class="kpi-value text-red-300">0%</div><div class="kpi-label">Відсоток промахів</div></div>
            </div>

            <!-- Charts -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
                <!-- Воронка -->
                <div class="card">
                    <h3 class="text-lg font-semibold mb-4">Воронка ефективності</h3>
                    <div class="chart-container">
                        <div id="funnelChart" class="html-funnel-container">
                            <div id="funnel-launches" class="funnel-segment">
                                <div class="funnel-segment-content">
                                    <div class="funnel-label">Кількість вильотів</div>
                                    <div class="funnel-value" id="funnel-value-launches">0</div>
                                </div>
                            </div>
                            <div id="funnel-detection" class="funnel-segment">
                                <div class="funnel-segment-content">
                                    <div class="funnel-label">Візуальний контакт</div>
                                    <div class="funnel-value" id="funnel-value-detection">0</div>
                                    <div class="funnel-percentage" id="funnel-perc-detection">(0%)</div>
                                </div>
                            </div>
                            <div id="funnel-attempt" class="funnel-segment">
                                <div class="funnel-segment-content">
                                    <div class="funnel-label">Спроба ураження</div>
                                    <div class="funnel-value" id="funnel-value-attempt">0</div>
                                    <div class="funnel-percentage" id="funnel-perc-attempt">(0%)</div>
                                </div>
                            </div>
                            <div id="funnel-destroyed" class="funnel-segment">
                                <div class="funnel-segment-content">
                                    <div class="funnel-label">Знищено</div>
                                    <div class="funnel-value" id="funnel-value-destroyed">0</div>
                                    <div class="funnel-percentage" id="funnel-perc-destroyed">(0%)</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Відсоткові показники ураження -->
                <div class="card">
                    <h3 class="text-lg font-semibold mb-4">Відсоткові показники ураження</h3>
                    <div class="chart-container">
                        <canvas id="killRateComparisonChart"></canvas>
                    </div>
                </div>

                <!-- Показники по днях -->
                <div class="card lg:col-span-2">
                    <h3 class="text-lg font-semibold mb-4">Пуски та Збиття по днях</h3>
                    <div class="chart-container"><canvas id="dailyKillRateChart"></canvas></div>
                </div>

                <!-- Ефективність по екіпажах -->
                <div class="card">
                    <h3 class="text-lg font-semibold mb-4">Ефективність по екіпажах</h3>
                    <div class="chart-container" style="height: 50vh;">
                        <canvas id="crewChart"></canvas>
                    </div>
                </div>

                <!-- Ефективність по точках злету -->
                <div class="card">
                    <h3 class="text-lg font-semibold mb-4">Ефективність по точках злету</h3>
                    <div class="chart-container" style="height: 50vh;">
                        <canvas id="takeoffPointChart"></canvas>
                    </div>
                </div>

                <!-- Знищено по типах БпЛА -->
                <div class="card">
                    <h3 class="text-lg font-semibold mb-4">Знищено по типах цілей</h3>
                    <div class="chart-container">
                        <canvas id="targetTypeChart"></canvas>
                    </div>
                </div>

                <!-- Ефективність по секторах -->
                <div class="card">
                    <h3 class="text-lg font-semibold mb-4">Знищено по секторах</h3>
                    <div class="chart-container">
                        <canvas id="sectorChart"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
    // --- Глобальний стан та константи ---
    const AppState = {
        originalData: [],
        charts: {},
        ui: {
            loader: document.getElementById('loader'),
            loadingMessage: document.getElementById('loadingMessage'),
            dashboardContent: document.getElementById('dashboardContent'),
            dateStart: document.getElementById('dateStart'),
            dateEnd: document.getElementById('dateEnd'),
            sectorFilter: document.getElementById('sectorFilter'),
            crewFilter: document.getElementById('crewFilter'),
            takeoffPointFilter: document.getElementById('takeoffPointFilter'),
            targetTypeFilter: document.getElementById('targetTypeFilter'),
            droneTypeFilter: document.getElementById('droneTypeFilter'), // NEW
            clearFiltersButton: document.getElementById('clearFiltersButton'),
        }
    };

    // Константи для значень з таблиці (для уникнення помилок)
    const DETECTION_OK = "Так, був візуальний контакт";
    const ATTEMPT = "Ціль наздогнали, була спроба ураження";
    const DESTROYED = "Збиття цілі";
    const NOT_DESTROYED = "Втрачений"; // Промах
    const RETURNED_OK = "Повернувся, цілий";
    const RETURNED_DMG = "Повернувся, пошкоджений";

    // Налаштування Chart.js
    Chart.defaults.color = '#9ca3af';
    Chart.defaults.font.family = "'Inter', sans-serif";
    Chart.register(ChartDataLabels);

    // Палітри
    const PALETTE_1 = ['#54a0ff', '#9b59b6', '#1dd1a1', '#ff9f43', '#00d2d3', '#ff6b6b', '#6c5ce7', '#feca57'];
    const PALETTE_2 = ['#2ecc71', '#f1c40f', '#e67e22', '#48dbfb', '#e74c3c', '#2980b9', '#d35400', '#8e44ad'];

    // --- Ініціалізація ---
    window.onload = initializeDashboard;

    async function initializeDashboard() {
        setLoadingState(true, 'Завантаження даних...');
        try {
            const data = await fetchData();
            AppState.originalData = preprocessData(data);
            populateFilters(AppState.originalData);
            addFilterListeners();
            resetFilters(); // Це автоматично викличе applyFilters()
            setLoadingState(false);
        } catch (error) {
            console.error("Помилка ініціалізації дашборду:", error);
            setLoadingState(true, `Помилка: ${error.message}`);
        }
    }

    function setLoadingState(isLoading, message = 'Завантаження...') {
        AppState.ui.loader.classList.toggle('hidden', !isLoading);
        AppState.ui.loadingMessage.textContent = message;
        AppState.ui.loadingMessage.classList.toggle('hidden', !isLoading);
        AppState.ui.dashboardContent.classList.toggle('hidden', isLoading);
    }

    // --- Завантаження та обробка даних ---
    async function fetchData(retries = 3, delay = 1000) {
        // URL опублікованої Google Таблиці
        const csvUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTNATRW_HxGW9zmFcJQR0vKq9eREDXuiTHqq3qyA9RzaiBLmvu-Ww7L7HJMuRHtz8Up3UHT86i-KYnu/pub?gid=652784530&single=true&output=csv';
        
        for (let i = 0; i < retries; i++) {
            try {
                // Додаємо timestamp, щоб уникнути кешування
                const response = await fetch(`${csvUrl}&t=${new Date().getTime()}`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const csvText = await response.text();
                return parseCSV(csvText);
            } catch (error) {
                console.warn(`Спроба ${i + 1} не вдалась:`, error);
                if (i === retries - 1) {
                    throw new Error('Не вдалося завантажити дані. Спробуйте оновити сторінку.');
                }
                setLoadingState(true, `Спроба завантаження ${i + 2}...`);
                await new Promise(res => setTimeout(res, delay));
            }
        }
    }

    function parseCSV(text) {
        const lines = text.split('\n');
        if (lines.length === 0) return [];

        const headerLine = lines[0].trim();
        const header = parseCSVLine(headerLine);

        const data = [];
        for (let i = 1; i < lines.length; i++) {
            const line = lines[i].trim();
            if (line) {
                const values = parseCSVLine(line);
                if (values.length === header.length) {
                    const obj = {};
                    for (let j = 0; j < header.length; j++) {
                        if(header[j]) {
                            obj[header[j]] = values[j];
                        }
                    }
                    data.push(obj);
                } else if (values.length > 0 && values[0] !== "") {
                     console.warn(`Пропуск рядка ${i}: очікувалось ${header.length} полів, отримано ${values.length}`, values);
                }
            }
        }
        return data;
    }

    function parseCSVLine(line) {
        const values = [];
        let currentVal = '';
        let inQuote = false;

        for (let i = 0; i < line.length; i++) {
            const char = line[i];
            if (char === '"') {
                if (inQuote && line[i+1] === '"') {
                    currentVal += '"';
                    i++;
                } else {
                    inQuote = !inQuote;
                }
            } else if (char === ',' && !inQuote) {
                values.push(currentVal);
                currentVal = '';
            } else {
                currentVal += char;
            }
        }
        values.push(currentVal);

        return values.map(val => {
            let cleanVal = val.trim();
            if (cleanVal.startsWith('"') && cleanVal.endsWith('"')) {
                cleanVal = cleanVal.substring(1, cleanVal.length - 1).replace(/""/g, '"');
            }
            return cleanVal.trim();
        });
    }

    function preprocessData(data) {
        return data
            .filter(row => row.flight_start_datetime && row.uuid)
            .map(row => {
                const fullTimestamp = row.flight_start_datetime;
                const onlyDate = fullTimestamp.split('T')[0] || fullTimestamp;
                const dateParts = fullTimestamp.split(' ');
                const finalDate = dateParts.length > 1 ? dateParts[0] : fullTimestamp;
                
                // Обробка unofficial_drone_type
                let droneType = row.unofficial_drone_type;
                if (!droneType || droneType.trim() === '') {
                    droneType = "Не вказано";
                }

                return {
                    ...row,
                    date: finalDate, 
                    daily_grouping_label: finalDate, 
                    target_type: row.target_type || "Невідомо",
                    sector: row.sector || "Невідомо",
                    crew: row.crew || "Невідомо",
                    takeoff_point: row.takeoff_point || "Невідомо",
                    unofficial_drone_type: droneType // Додано
                };
            });
    }

    // --- Фільтрація ---
    function populateFilters(data) {
        const { dateStart, dateEnd, sectorFilter, crewFilter, takeoffPointFilter, targetTypeFilter, droneTypeFilter } = AppState.ui;

        if (data.length > 0) {
            const dates = data.map(d => d.date).sort();
            dateStart.value = dates[0];
            dateStart.min = dates[0];
            dateEnd.value = dates[dates.length - 1];
            dateEnd.max = dates[dates.length - 1];
        }

        const populateSelect = (select, items, allLabel) => {
            select.innerHTML = `<option value="all">${allLabel}</option>`;
            Array.from(items).sort().forEach(item => {
                if(item && item !== 'Невідомо' && item !== 'null' && item !== 'undefined') {
                    const option = document.createElement('option');
                    option.value = item;
                    option.textContent = item;
                    select.appendChild(option);
                }
            });
        };

        const crews = new Set(data.map(d => d.crew));
        const takeoffPoints = new Set(data.map(d => d.takeoff_point));
        const targetTypes = new Set(data.map(d => d.target_type));
        // Отримуємо унікальні типи засобів
        const droneTypes = new Set(data.map(d => d.unofficial_drone_type));

        const fixedSectors = ["ДАРКНОД", "Київ", "Південь", "Північ"];
        sectorFilter.innerHTML = `<option value="all">Всі сектори</option>`;
        fixedSectors.forEach(sector => {
            const option = document.createElement('option');
            option.value = sector;
            option.textContent = sector;
            sectorFilter.appendChild(option);
        });

        populateSelect(crewFilter, crews, 'Всі екіпажі');
        populateSelect(takeoffPointFilter, takeoffPoints, 'Всі точки злету');
        populateSelect(targetTypeFilter, targetTypes, 'Всі типи цілей');
        populateSelect(droneTypeFilter, droneTypes, 'Всі типи засобів'); // Populate
    }

    function addFilterListeners() {
        const { dateStart, dateEnd, sectorFilter, crewFilter, takeoffPointFilter, targetTypeFilter, droneTypeFilter, clearFiltersButton } = AppState.ui;

        [dateStart, dateEnd, sectorFilter, crewFilter, takeoffPointFilter, targetTypeFilter, droneTypeFilter].forEach(el => {
            el.addEventListener('change', applyFilters);
        });
        clearFiltersButton.addEventListener('click', resetFilters);
    }

    function resetFilters() {
        const dateStart = document.getElementById('dateStart');
        const dateEnd = document.getElementById('dateEnd');
        const sectorFilter = document.getElementById('sectorFilter');
        const crewFilter = document.getElementById('crewFilter');
        const takeoffPointFilter = document.getElementById('takeoffPointFilter');
        const targetTypeFilter = document.getElementById('targetTypeFilter');
        const droneTypeFilter = document.getElementById('droneTypeFilter');

        if (AppState.originalData.length > 0) {
            const dates = AppState.originalData.map(d => d.date).sort();
            dateStart.value = dates[0];
            dateEnd.value = dates[dates.length - 1];
        }
        sectorFilter.value = 'all';
        crewFilter.value = 'all';
        takeoffPointFilter.value = 'all';
        targetTypeFilter.value = 'all';
        droneTypeFilter.value = 'all';

        applyFilters();
    }

    function applyFilters() {
        const filters = {
            startDate: document.getElementById('dateStart').value,
            endDate: document.getElementById('dateEnd').value,
            sector: document.getElementById('sectorFilter').value,
            crew: document.getElementById('crewFilter').value,
            takeoffPoint: document.getElementById('takeoffPointFilter').value,
            targetType: document.getElementById('targetTypeFilter').value,
            droneType: document.getElementById('droneTypeFilter').value,
        };

        const filteredData = AppState.originalData.filter(row => {
            return (!filters.startDate || row.date >= filters.startDate) &&
                   (!filters.endDate || row.date <= filters.endDate) &&
                   (filters.sector === 'all' || row.sector === filters.sector) &&
                   (filters.crew === 'all' || row.crew === filters.crew) &&
                   (filters.takeoffPoint === 'all' || row.takeoff_point === filters.takeoffPoint) &&
                   (filters.targetType === 'all' || row.target_type === filters.targetType) &&
                   (filters.droneType === 'all' || row.unofficial_drone_type === filters.droneType);
        });

        updateDashboard(filteredData);
    }

    // --- Оновлення Дашборду ---
    function updateDashboard(data) {
        const validData = data.filter(d => d.uuid && d.uuid.length > 10);

        const launch_uuids = new Set(validData.map(d => d.uuid));
        const detection_uuids = new Set(validData.filter(d => d.target_detection === DETECTION_OK).map(d => d.uuid));
        const attempt_uuids = new Set(validData.filter(d => d.hit_target_attempt === ATTEMPT).map(d => d.uuid));
        const destroyed_uuids = new Set(validData.filter(d => d.drone_status === DESTROYED).map(d => d.uuid));
        const not_destroyed_uuids = new Set(validData.filter(d => d.drone_status === NOT_DESTROYED).map(d => d.uuid));
        const returned_uuids = new Set(validData.filter(d => d.drone_status === RETURNED_OK || d.drone_status === RETURNED_DMG).map(d => d.uuid));

        const totalLaunches = launch_uuids.size;
        const totalDetection = detection_uuids.size;
        const totalAttempt = attempt_uuids.size;
        const totalDestroyed = destroyed_uuids.size;
        const totalNotDestroyed = not_destroyed_uuids.size;
        const totalReturned = returned_uuids.size;

        document.getElementById('kpiLaunches').textContent = totalLaunches;
        document.getElementById('kpiDetection').textContent = totalDetection;
        document.getElementById('kpiAttempt').textContent = totalAttempt;
        document.getElementById('kpiDestroyed').textContent = totalDestroyed;
        document.getElementById('kpiNotDestroyed').textContent = totalNotDestroyed;
        document.getElementById('kpiReturned').textContent = totalReturned;

        const effDetection = totalLaunches > 0 ? (totalDetection / totalLaunches) * 100 : 0;
        const effDestroy = totalLaunches > 0 ? (totalDestroyed / totalLaunches) * 100 : 0;
        
        const totalAttempt_flights = totalAttempt;
        const totalDestroyed_from_attempt_flights = new Set(
            validData
                .filter(d => d.hit_target_attempt === ATTEMPT && d.drone_status === DESTROYED)
                .map(d => d.uuid)
        ).size;
        const effAttempt = totalAttempt_flights > 0 ? (totalDestroyed_from_attempt_flights / totalAttempt_flights) * 100 : 0;

        const effMiss = totalLaunches > 0 ? (totalNotDestroyed / totalLaunches) * 100 : 0;

        document.getElementById('kpiEffDetection').textContent = effDetection.toFixed(1) + '%';
        document.getElementById('kpiEffAttempt').textContent = effAttempt.toFixed(1) + '%';
        document.getElementById('kpiEffDestroy').textContent = effDestroy.toFixed(1) + '%';
        document.getElementById('kpiEffMiss').textContent = effMiss.toFixed(1) + '%';

        updateFunnelChart({
            launched: totalLaunches,
            detected: totalDetection,
            attempt: totalAttempt,
            destroyed: totalDestroyed
        });

        updateKillRateComparisonChart({
            fromLaunches: effDestroy,
            fromDetection: totalDetection > 0 ? (totalDestroyed / totalDetection) * 100 : 0,
            fromAttempts: effAttempt
        });

        updateDailyChart(validData);

        AppState.charts.crew = createHorizontalBarChart('crewChart', AppState.charts.crew, validData, 'crew', PALETTE_1, 15);
        AppState.charts.takeoffPoint = createHorizontalBarChart('takeoffPointChart', AppState.charts.takeoffPoint, validData, 'takeoff_point', PALETTE_2, 15);
        AppState.charts.targetType = createDoughnutChart('targetTypeChart', AppState.charts.targetType, validData, 'target_type', PALETTE_1);
        AppState.charts.sector = createDoughnutChart('sectorChart', AppState.charts.sector, validData, 'sector', PALETTE_2);
    }

    // --- Функції оновлення графіків ---

    function updateFunnelChart(totals) {
        const { launched, detected, attempt, destroyed } = totals;
        
        document.getElementById('funnel-value-launches').textContent = launched;
        document.getElementById('funnel-value-detection').textContent = detected;
        document.getElementById('funnel-value-attempt').textContent = attempt;
        document.getElementById('funnel-value-destroyed').textContent = destroyed;

        const percDetected = launched > 0 ? (detected / launched * 100) : 0;
        const percAttempt = detected > 0 ? (attempt / detected * 100) : 0;
        const percDestroyed = attempt > 0 ? (destroyed / attempt * 100) : 0;

        document.getElementById('funnel-perc-detection').textContent = `(${percDetected.toFixed(0)}% від вильотів)`;
        document.getElementById('funnel-perc-attempt').textContent = `(${percAttempt.toFixed(0)}% від виявлених)`;
        document.getElementById('funnel-perc-destroyed').textContent = `(${percDestroyed.toFixed(0)}% від спроб)`;
    }

    function updateKillRateComparisonChart(rates) {
        if (AppState.charts.killRateComparison) AppState.charts.killRateComparison.destroy();

        const options = getChartOptions();
        options.indexAxis = 'y';
        options.scales.x.max = 100;
        options.scales.x.ticks = { callback: (value) => value + '%' };
        options.plugins.datalabels = { display: true, anchor: 'end', align: 'right', color: 'white', font: { weight: 'bold' }, formatter: (value) => `${value.toFixed(1)}%` };

        AppState.charts.killRateComparison = new Chart(document.getElementById('killRateComparisonChart'), {
            type: 'bar',
            data: {
                labels: ['% збиття від Спроб', '% збиття від Виявлених', '% збиття від Пусків'],
                datasets: [{
                    label: 'Ефективність ураження',
                    data: [rates.fromAttempts, rates.fromDetection, rates.fromLaunches],
                    backgroundColor: ['#2ecc71', '#f1c40f', '#3498db']
                }]
            },
            options: options
        });
    }

    /**
     * Оновлена функція для побудови комбінованого графіка (Стовпчики + Лінія)
     */
    function updateDailyChart(data) {
        if (AppState.charts.dailyKillRate) AppState.charts.dailyKillRate.destroy();

        const dailyData = data.reduce((acc, row) => {
            const dayLabel = row.daily_grouping_label; 
            if (!acc[dayLabel]) {
                acc[dayLabel] = {
                    launch_uuids: new Set(),
                    destroyed_uuids: new Set()
                };
            }
            acc[dayLabel].launch_uuids.add(row.uuid);

            if (row.drone_status === DESTROYED) {
                acc[dayLabel].destroyed_uuids.add(row.uuid);
            }
            return acc;
        }, {});

        const sortedDays = Object.keys(dailyData).sort();
        const labels = sortedDays;

        const launchesData = sortedDays.map(day => dailyData[day].launch_uuids.size);
        const destroyedData = sortedDays.map(day => dailyData[day].destroyed_uuids.size);

        const options = getChartOptions();
        options.plugins.tooltip = {
            callbacks: {
                label: function(context) {
                    const label = context.dataset.label || '';
                    const value = context.raw;
                    return label.replace(' (унік. вильотів)', '') + `: ${value}`;
                },
                footer: function(tooltipItems) {
                    // Знаходимо значення для поточного індексу з обох масивів, бо один може бути лінією
                    const i = tooltipItems[0].dataIndex;
                    const totalLaunches = launchesData[i];
                    const totalDestroyed = destroyedData[i];
                    const kr = totalLaunches > 0 ? (totalDestroyed / totalLaunches * 100) : 0;
                    return `\nВсього вильотів: ${totalLaunches}\nЗнищено: ${totalDestroyed}\nKill Rate: ${kr.toFixed(0)}%`;
                }
            }
        };
        
        options.scales.x = { 
            type: 'category', 
            grid: { display: false }, 
            ticks: { color: '#9ca3af' } 
        };

        // Змінюємо тип графіка та налаштування датасетів для комбінованого виду
        AppState.charts.dailyKillRate = new Chart(document.getElementById('dailyKillRateChart'), {
            type: 'bar', // Базовий тип - бар, але ми додамо лінію
            data: {
                labels,
                datasets: [
                    {
                        label: 'Кількість пусків',
                        data: launchesData,
                        backgroundColor: 'rgba(59, 130, 246, 0.7)', // Синій
                        order: 2 // Бар позаду
                    },
                    {
                        type: 'line', // Явно вказуємо тип лінія
                        label: 'Знищено',
                        data: destroyedData,
                        borderColor: '#facc15', // Яскраво жовтий (Yellow-400)
                        backgroundColor: '#facc15',
                        borderWidth: 3,
                        pointRadius: 2,
                        pointHoverRadius: 4,
                        tension: 0.3, // Плавність ліній
                        order: 1 // Лінія зверху
                    }
                ]
            },
            options: options
        });
    }

    // --- Універсальні функції для графіків ---

    function createHorizontalBarChart(canvasId, chartInstance, data, dataKey, colorPalette, topN = 10) {
        const ctx = document.getElementById(canvasId).getContext('2d');
        if (chartInstance) chartInstance.destroy();

        const validData = data.filter(d => d.uuid && d.uuid.length > 10);

        const dataMap = validData.reduce((acc, item) => {
            const key = item[dataKey];
            const uuid = item.uuid;
            if (key && key !== 'null' && key !== 'undefined' && uuid) {
                if (!acc[key]) {
                    acc[key] = {
                        launch_uuids: new Set(),
                        destroyed_uuids: new Set(),
                    };
                }
                acc[key].launch_uuids.add(uuid);

                if (item.drone_status === DESTROYED) {
                    acc[key].destroyed_uuids.add(uuid);
                }
            }
            return acc;
        }, {});

        const sortedData = Object.entries(dataMap)
            .filter(([, stats]) => stats.destroyed_uuids.size > 0)
            .sort(([, a], [, b]) => b.destroyed_uuids.size - a.destroyed_uuids.size)
            .slice(0, topN);

        if (sortedData.length === 0) {
            return showEmptyChartMessage(ctx);
        }

        const options = getChartOptions();
        options.indexAxis = 'y';
        options.plugins.datalabels = {
            anchor: 'end', align: 'right', color: 'white', font: { weight: 'bold' },
            formatter: (value, context) => {
                const stats = sortedData[context.dataIndex][1];
                const totalLaunches = stats.launch_uuids.size;
                // Рахуємо "Ефективність знищення від пусків"
                const kr = totalLaunches > 0 ? (value / totalLaunches) * 100 : 0;
                return `${value} збито (${kr.toFixed(0)}%)`;
            }
        };

        return new Chart(ctx, {
            type: 'bar',
            data: {
                labels: sortedData.map(c => c[0]),
                datasets: [{
                    label: 'Знищено',
                    data: sortedData.map(c => c[1].destroyed_uuids.size),
                    backgroundColor: colorPalette,
                }]
            },
            options: options
        });
    }

    function createDoughnutChart(canvasId, chartInstance, data, dataKey, colorPalette) {
        const ctx = document.getElementById(canvasId).getContext('2d');
        if (chartInstance) chartInstance.destroy();

        const validData = data.filter(d => d.uuid && d.uuid.length > 10);

        const aggregated = validData
            .filter(i => i.drone_status === DESTROYED)
            .reduce((acc, item) => {
                const key = item[dataKey];
                const uuid = item.uuid;
                if (key && key !== 'null' && key !== 'undefined' && uuid) { 
                    if (!acc[key]) {
                        acc[key] = new Set();
                    }
                    acc[key].add(uuid); 
                }
                return acc;
            }, {});

        const sortedData = Object.entries(aggregated)
            .map(([key, uuidSet]) => [key, uuidSet.size])
            .sort(([,a],[,b]) => b-a);

        if (sortedData.length === 0) {
            return showEmptyChartMessage(ctx);
        }

        const total = sortedData.reduce((sum, item) => sum + item[1], 0);

        return new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: sortedData.map(d => d[0]),
                datasets: [{
                    data: sortedData.map(d => d[1]),
                    backgroundColor: Array.from({ length: sortedData.length }, (_, i) => colorPalette[i % colorPalette.length]),
                    borderWidth: 0
                }]
            },
            options: {
                responsive: true, maintainAspectRatio: false,
                plugins: {
                    legend: { position: 'right', labels: { boxWidth: 20, color: '#e5e7eb' } },
                    datalabels: {
                        color: 'white', textAlign: 'center', font: { weight: 'bold', size: 11 },
                        formatter: (value) => {
                            const p = total > 0 ? (value / total * 100) : 0;
                            if (p < 4) return null;
                            return `${value}\n(${p.toFixed(0)}%)`;
                        }
                    }
                }
            }
        });
    }

    function getChartOptions() {
        return {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { position: 'top', labels: { color: '#e5e7eb' } },
                datalabels: { display: false }
            },
            scales: {
                x: { grid: { display: false }, ticks: { color: '#9ca3af' } },
                y: { grid: { color: '#374151' }, ticks: { beginAtZero: true, color: '#9ca3af' } }
            }
        };
    }

    function showEmptyChartMessage(ctx) {
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx.save();
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#9ca3af';
        ctx.font = "16px 'Inter', sans-serif";
        ctx.fillText('Немає даних для відображення', ctx.canvas.width / 2, ctx.canvas.height / 2);
        ctx.restore();
        return null;
    }
    </script>
</body>
</html>
